---
title: "Top-K-Frequent-Elements"
question_id: "347"
question_link: "https://leetcode.com/problems/top-k-frequent-elements/description/"
difficulty: "Medium"
---

First thoughts we are able to use a hashmap to complete this, by creating a dictionary where the key is the integer that appears and value is the counter for that specfic integer value. Then we can use `most_common` to sort the most common integer to least common. Finally we return only the `num` based on the `k` inputted by appending to end of a completely new `result` list and return final value.


```python
from collections import Counter

class Solution(object):
    def topKFrequent(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """

        result = []
        # Create a counter object which counts number of times numbers appear in nums list
        counter = Counter(nums)
        # Use collections built in most_common to sort values from most common to least
        most_common = counter.most_common(k)
        
        # Return only numbers in result
        for num, freq in most_common:
            result.append(num)

        return result
```

> Time Complexity : `O(n log n)`
> 
> Space Complexity : `O(n)`

However even though I thought about using the collections built in counter mechanisim I realized how I didn't actually know how to implment it by hand so i'll redo the question. My implementation and idea is correct however because it is a correct answer. But in the end its not the way i wanted to do it.